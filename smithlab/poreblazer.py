"""
Copyright 2025. Brandon C. Tapia

MIT License
"""


def write_xyz(lammps_in, xyz_out="system.xyz"):
    """
    Writes an XYZ file from a LAMMPS data file (atom_style full),
    formatted for use with PoreBlazer.
    """

    atom_section = False
    atom_lines = []

    with open(lammps_in, "r", encoding="utf-8") as file:
        lines = file.readlines()

    for i, line in enumerate(lines):
        stripped = line.strip()
        columns = stripped.split()

        if stripped.startswith("Atoms"):
            atom_section = True
            continue

        if atom_section:
            if not columns:
                continue
            if columns[0].isalpha():
                break
            atom_lines.append(columns)

    with open(xyz_out, "w", encoding="utf-8") as file:
        file.write(f"{len(atom_lines)}\n")
        file.write("Generated by smithlab.poreblazer.write_xyz\n")
        for cols in atom_lines:
            atom_type = cols[2]
            x, y, z = cols[4], cols[5], cols[6]
            file.write(f"{atom_type} {x} {y} {z}\n")

    return


def write_forcefield(lammps_in, ff_out="ff.atoms"):

    mass_section = False
    pair_section = False

    kB = 1.9872e-3  # kcal/mol-K

    identifiers = []
    molwt = []
    energies = []
    sigma = []

    with open(lammps_in, "r", encoding="utf-8") as file:
        lines = file.readlines()

    for i, line in enumerate(lines):
        stripped = line.strip()
        columns = stripped.split()

        if stripped.startswith("Masses"):
            mass_section = True
            continue

        if stripped.startswith("Pair Coeffs"):
            pair_section = True
            mass_section = False
            continue

        if mass_section:
            if not columns:
                continue
            if columns[0].isalpha():
                mass_section = False
                continue

            identifiers.append(columns[0])
            molwt.append(columns[1])

        if pair_section:
            if not columns:
                continue
            if columns[0].isalpha():
                break

            energies.append(float(columns[1]) / kB)

            sigma.append(columns[2])

    with open(ff_out, "w", encoding="utf-8") as file:
        file.write(f"{len(identifiers)}\n")

        for i, identifier in enumerate(identifiers):
            file.write(
                f"{identifier} {float(sigma[i]):.4f} {float(energies[i]):.2f} {float(molwt[i]):.3f}\n"
            )

        file.write("! name of framework atom, diameter (LJ sigma) in A, epsilon in K, mol weight\n")

    return


def write_defaults():

    with open("defaults.dat", "w", encoding="utf-8") as file:
        file.write("ff.atoms\n2.58, 10.22, 298, 12.8\n3.314\n500\n0.2\n20.0, 0.25\n21908391\n0\n\n")
        file.write("! Default forcefield: from LAMMPS file\n")
        file.write(
            "! Helium atom sigma (A), helium atom epsilon (K), temperature (K), cutoff distance (A)\n"
        )
        file.write("! Nitrogen atom sigma (A)\n")
        file.write("! Number of samples per atom for the surface area calculation\n")
        file.write("! 0.2: Cubelet size (A)\n")
        file.write("! Largest anticipated pore diameter (A), size of the bin for PSD (A)\n")
        file.write("! Random number seed\n")
        file.write("! Visualization options: 1 -xyz, 2 - grd, 3 - both; 0 - none\n\n")
        file.write("! Do not change these values unless you know what you are doing\n")

    return


def write_input(xyz_in="system.xyz"):

    x_array = []
    y_array = []
    z_array = []

    with open(xyz_in, "r", encoding="utf-8") as file:
        lines = file.readlines()

    for _, line in enumerate(lines):

        stripped = line.strip()
        columns = stripped.split()

        if len(columns) == 1 or columns[0].isalpha():
            continue

        x_array.append(float(columns[1]))
        y_array.append(float(columns[2]))
        z_array.append(float(columns[3]))

    x_length = max(x_array) - min(x_array)
    y_length = max(y_array) - min(y_array)
    z_length = max(z_array) - min(z_array)

    with open("input.dat", "w", encoding="utf-8") as file:
        file.write(f"{xyz_in}\n{x_length} {y_length} {z_length}\n90 90 90")

    return


def setup_PB(lammps_in):

    write_xyz(lammps_in)
    write_forcefield(lammps_in)
    write_defaults()
    write_input()

    return
